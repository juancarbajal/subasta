<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>libs&#x2F;plugins&#x2F;tiny_mce&#x2F;plugins&#x2F;lists&#x2F;editor_plugin_src.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/admin.html">admin</a></li>
            
                <li><a href="..&#x2F;classes/all-modules.html">all-modules</a></li>
            
                <li><a href="..&#x2F;classes/default.html">default</a></li>
            
                <li><a href="..&#x2F;classes/jcarousel.html">jcarousel</a></li>
            
                <li><a href="..&#x2F;classes/tinymce.plugins.AutoSave.html">tinymce.plugins.AutoSave</a></li>
            
                <li><a href="..&#x2F;classes/tinymce.plugins.ContextMenu.html">tinymce.plugins.ContextMenu</a></li>
            
                <li><a href="..&#x2F;classes/usuario.html">usuario</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/ad-actions.html">ad-actions</a></li>
            
                <li><a href="..&#x2F;modules/add-class-middle.html">add-class-middle</a></li>
            
                <li><a href="..&#x2F;modules/add-favorites.html">add-favorites</a></li>
            
                <li><a href="..&#x2F;modules/all-checked-uncheked.html">all-checked-uncheked</a></li>
            
                <li><a href="..&#x2F;modules/banner-top classified.html">banner-top classified</a></li>
            
                <li><a href="..&#x2F;modules/carousel-products.html">carousel-products</a></li>
            
                <li><a href="..&#x2F;modules/count-word.html">count-word</a></li>
            
                <li><a href="..&#x2F;modules/data-ubigeo.html">data-ubigeo</a></li>
            
                <li><a href="..&#x2F;modules/geotags.html">geotags</a></li>
            
                <li><a href="..&#x2F;modules/impress-ad-list.html">impress-ad-list</a></li>
            
                <li><a href="..&#x2F;modules/lightbox-logIn-signUp.html">lightbox-logIn-signUp</a></li>
            
                <li><a href="..&#x2F;modules/moduleName.html">moduleName</a></li>
            
                <li><a href="..&#x2F;modules/placeholder.html">placeholder</a></li>
            
                <li><a href="..&#x2F;modules/preview-impress.html">preview-impress</a></li>
            
                <li><a href="..&#x2F;modules/register-category.html">register-category</a></li>
            
                <li><a href="..&#x2F;modules/remove-class-home.html">remove-class-home</a></li>
            
                <li><a href="..&#x2F;modules/report-ad.html">report-ad</a></li>
            
                <li><a href="..&#x2F;modules/scrollTop.html">scrollTop</a></li>
            
                <li><a href="..&#x2F;modules/search-categories.html">search-categories</a></li>
            
                <li><a href="..&#x2F;modules/send-ad-friend.html">send-ad-friend</a></li>
            
                <li><a href="..&#x2F;modules/send-list-ad-email.html">send-list-ad-email</a></li>
            
                <li><a href="..&#x2F;modules/show-advanced-search.html">show-advanced-search</a></li>
            
                <li><a href="..&#x2F;modules/show-example-ads.html">show-example-ads</a></li>
            
                <li><a href="..&#x2F;modules/show-login-trigger.html">show-login-trigger</a></li>
            
                <li><a href="..&#x2F;modules/show-photo-products.html">show-photo-products</a></li>
            
                <li><a href="..&#x2F;modules/show-popup.html">show-popup</a></li>
            
                <li><a href="..&#x2F;modules/show-questions.html">show-questions</a></li>
            
                <li><a href="..&#x2F;modules/show-register-trigger.html">show-register-trigger</a></li>
            
                <li><a href="..&#x2F;modules/show-video.html">show-video</a></li>
            
                <li><a href="..&#x2F;modules/showMoreCategories.html">showMoreCategories</a></li>
            
                <li><a href="..&#x2F;modules/some-module4.html">some-module4</a></li>
            
                <li><a href="..&#x2F;modules/tinymce-register.html">tinymce-register</a></li>
            
                <li><a href="..&#x2F;modules/uploader-photos.html">uploader-photos</a></li>
            
                <li><a href="..&#x2F;modules/validate.html">validate</a></li>
            
                <li><a href="..&#x2F;modules/validate-document.html">validate-document</a></li>
            
                <li><a href="..&#x2F;modules/validate-image.html">validate-image</a></li>
            
                <li><a href="..&#x2F;modules/venta.html">venta</a></li>
            
                <li><a href="..&#x2F;modules/yOSON.html">yOSON</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: libs&#x2F;plugins&#x2F;tiny_mce&#x2F;plugins&#x2F;lists&#x2F;editor_plugin_src.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * editor_plugin_src.js
 *
 * Copyright 2011, Moxiecode Systems AB
 * Released under LGPL License.
 *
 * License: http:&#x2F;&#x2F;tinymce.moxiecode.com&#x2F;license
 * Contributing: http:&#x2F;&#x2F;tinymce.moxiecode.com&#x2F;contributing
 *&#x2F;

(function() {
	var each = tinymce.each, Event = tinymce.dom.Event, bookmark;

	&#x2F;&#x2F; Skips text nodes that only contain whitespace since they aren&#x27;t semantically important.
	function skipWhitespaceNodes(e, next) {
		while (e &amp;&amp; (e.nodeType === 8 || (e.nodeType === 3 &amp;&amp; &#x2F;^[ \t\n\r]*$&#x2F;.test(e.nodeValue)))) {
			e = next(e);
		}
		return e;
	}

	function skipWhitespaceNodesBackwards(e) {
		return skipWhitespaceNodes(e, function(e) {
			return e.previousSibling;
		});
	}

	function skipWhitespaceNodesForwards(e) {
		return skipWhitespaceNodes(e, function(e) {
			return e.nextSibling;
		});
	}

	function hasParentInList(ed, e, list) {
		return ed.dom.getParent(e, function(p) {
			return tinymce.inArray(list, p) !== -1;
		});
	}

	function isList(e) {
		return e &amp;&amp; (e.tagName === &#x27;OL&#x27; || e.tagName === &#x27;UL&#x27;);
	}

	function splitNestedLists(element, dom) {
		var tmp, nested, wrapItem;
		tmp = skipWhitespaceNodesBackwards(element.lastChild);
		while (isList(tmp)) {
			nested = tmp;
			tmp = skipWhitespaceNodesBackwards(nested.previousSibling);
		}
		if (nested) {
			wrapItem = dom.create(&#x27;li&#x27;, { style: &#x27;list-style-type: none;&#x27;});
			dom.split(element, nested);
			dom.insertAfter(wrapItem, nested);
			wrapItem.appendChild(nested);
			wrapItem.appendChild(nested);
			element = wrapItem.previousSibling;
		}
		return element;
	}

	function attemptMergeWithAdjacent(e, allowDifferentListStyles, mergeParagraphs) {
		e = attemptMergeWithPrevious(e, allowDifferentListStyles, mergeParagraphs);
		return attemptMergeWithNext(e, allowDifferentListStyles, mergeParagraphs);
	}

	function attemptMergeWithPrevious(e, allowDifferentListStyles, mergeParagraphs) {
		var prev = skipWhitespaceNodesBackwards(e.previousSibling);
		if (prev) {
			return attemptMerge(prev, e, allowDifferentListStyles ? prev : false, mergeParagraphs);
		} else {
			return e;
		}
	}

	function attemptMergeWithNext(e, allowDifferentListStyles, mergeParagraphs) {
		var next = skipWhitespaceNodesForwards(e.nextSibling);
		if (next) {
			return attemptMerge(e, next, allowDifferentListStyles ? next : false, mergeParagraphs);
		} else {
			return e;
		}
	}

	function attemptMerge(e1, e2, differentStylesMasterElement, mergeParagraphs) {
		if (canMerge(e1, e2, !!differentStylesMasterElement, mergeParagraphs)) {
			return merge(e1, e2, differentStylesMasterElement);
		} else if (e1 &amp;&amp; e1.tagName === &#x27;LI&#x27; &amp;&amp; isList(e2)) {
			&#x2F;&#x2F; Fix invalidly nested lists.
			e1.appendChild(e2);
		}
		return e2;
	}

	function canMerge(e1, e2, allowDifferentListStyles, mergeParagraphs) {
		if (!e1 || !e2) {
			return false;
		} else if (e1.tagName === &#x27;LI&#x27; &amp;&amp; e2.tagName === &#x27;LI&#x27;) {
			return e2.style.listStyleType === &#x27;none&#x27; || containsOnlyAList(e2);
		} else if (isList(e1)) {
			return (e1.tagName === e2.tagName &amp;&amp; (allowDifferentListStyles || e1.style.listStyleType === e2.style.listStyleType)) || isListForIndent(e2);
		} else return mergeParagraphs &amp;&amp; e1.tagName === &#x27;P&#x27; &amp;&amp; e2.tagName === &#x27;P&#x27;;
	}

	function isListForIndent(e) {
		var firstLI = skipWhitespaceNodesForwards(e.firstChild), lastLI = skipWhitespaceNodesBackwards(e.lastChild);
		return firstLI &amp;&amp; lastLI &amp;&amp; isList(e) &amp;&amp; firstLI === lastLI &amp;&amp; (isList(firstLI) || firstLI.style.listStyleType === &#x27;none&#x27; || containsOnlyAList(firstLI));
	}

	function containsOnlyAList(e) {
		var firstChild = skipWhitespaceNodesForwards(e.firstChild), lastChild = skipWhitespaceNodesBackwards(e.lastChild);
		return firstChild &amp;&amp; lastChild &amp;&amp; firstChild === lastChild &amp;&amp; isList(firstChild);
	}

	function merge(e1, e2, masterElement) {
		var lastOriginal = skipWhitespaceNodesBackwards(e1.lastChild), firstNew = skipWhitespaceNodesForwards(e2.firstChild);
		if (e1.tagName === &#x27;P&#x27;) {
			e1.appendChild(e1.ownerDocument.createElement(&#x27;br&#x27;));
		}
		while (e2.firstChild) {
			e1.appendChild(e2.firstChild);
		}
		if (masterElement) {
			e1.style.listStyleType = masterElement.style.listStyleType;
		}
		e2.parentNode.removeChild(e2);
		attemptMerge(lastOriginal, firstNew, false);
		return e1;
	}

	function findItemToOperateOn(e, dom) {
		var item;
		if (!dom.is(e, &#x27;li,ol,ul&#x27;)) {
			item = dom.getParent(e, &#x27;li&#x27;);
			if (item) {
				e = item;
			}
		}
		return e;
	}

	tinymce.create(&#x27;tinymce.plugins.Lists&#x27;, {
		init: function(ed) {
			var LIST_TABBING = &#x27;TABBING&#x27;;
			var LIST_EMPTY_ITEM = &#x27;EMPTY&#x27;;
			var LIST_ESCAPE = &#x27;ESCAPE&#x27;;
			var LIST_PARAGRAPH = &#x27;PARAGRAPH&#x27;;
			var LIST_UNKNOWN = &#x27;UNKNOWN&#x27;;
			var state = LIST_UNKNOWN;

			function isTabInList(e) {
				&#x2F;&#x2F; Don&#x27;t indent on Ctrl+Tab or Alt+Tab
				return e.keyCode === tinymce.VK.TAB &amp;&amp; !(e.altKey || e.ctrlKey) &amp;&amp;
					(ed.queryCommandState(&#x27;InsertUnorderedList&#x27;) || ed.queryCommandState(&#x27;InsertOrderedList&#x27;));
			}

			function isOnLastListItem() {
				var li = getLi();
				var grandParent = li.parentNode.parentNode;
				var isLastItem = li.parentNode.lastChild === li;
				return isLastItem &amp;&amp; !isNestedList(grandParent) &amp;&amp; isEmptyListItem(li);
			}

			function isNestedList(grandParent) {
				if (isList(grandParent)) {
					return grandParent.parentNode &amp;&amp; grandParent.parentNode.tagName === &#x27;LI&#x27;;
				} else {
					return  grandParent.tagName === &#x27;LI&#x27;;
				}
			}

			function isInEmptyListItem() {
				return ed.selection.isCollapsed() &amp;&amp; isEmptyListItem(getLi());
			}

			function getLi() {
				var n = ed.selection.getStart();
				&#x2F;&#x2F; Get start will return BR if the LI only contains a BR or an empty element as we use these to fix caret position
				return ((n.tagName == &#x27;BR&#x27; || n.tagName == &#x27;&#x27;) &amp;&amp; n.parentNode.tagName == &#x27;LI&#x27;) ? n.parentNode : n;
			}

			function isEmptyListItem(li) {
				var numChildren = li.childNodes.length;
				if (li.tagName === &#x27;LI&#x27;) {
					return numChildren == 0 ? true : numChildren == 1 &amp;&amp; (li.firstChild.tagName == &#x27;&#x27; || li.firstChild.tagName == &#x27;BR&#x27; || isEmptyIE9Li(li));
				}
				return false;
			}

			function isEmptyIE9Li(li) {
				&#x2F;&#x2F; only consider this to be last item if there is no list item content or that content is nbsp or space since IE9 creates these
				var lis = tinymce.grep(li.parentNode.childNodes, function(n) {return n.tagName == &#x27;LI&#x27;});
				var isLastLi = li == lis[lis.length - 1];
				var child = li.firstChild;
				return tinymce.isIE9 &amp;&amp; isLastLi &amp;&amp; (child.nodeValue == String.fromCharCode(160) || child.nodeValue == String.fromCharCode(32));
			}

			function isEnter(e) {
				return e.keyCode === tinymce.VK.ENTER;
			}

			function isEnterWithoutShift(e) {
				return isEnter(e) &amp;&amp; !e.shiftKey;
			}

			function getListKeyState(e) {
				if (isTabInList(e)) {
					return LIST_TABBING;
				} else if (isEnterWithoutShift(e) &amp;&amp; isOnLastListItem()) {
					&#x2F;&#x2F; Returns LIST_UNKNOWN since breaking out of lists is handled by the EnterKey.js logic now
					&#x2F;&#x2F;return LIST_ESCAPE;
					return LIST_UNKNOWN;
				} else if (isEnterWithoutShift(e) &amp;&amp; isInEmptyListItem()) {
					return LIST_EMPTY_ITEM;
				} else {
					return LIST_UNKNOWN;
				}
			}

			function cancelDefaultEvents(ed, e) {
				&#x2F;&#x2F; list escape is done manually using outdent as it does not create paragraphs correctly in td&#x27;s
				if (state == LIST_TABBING || state == LIST_EMPTY_ITEM || tinymce.isGecko &amp;&amp; state == LIST_ESCAPE) {
					Event.cancel(e);
				}
			}

			function isCursorAtEndOfContainer() {
				var range = ed.selection.getRng(true);
				var startContainer = range.startContainer;
				if (startContainer.nodeType == 3) {
					var value = startContainer.nodeValue;
					if (tinymce.isIE9 &amp;&amp; value.length &gt; 1 &amp;&amp; value.charCodeAt(value.length-1) == 32) {
						&#x2F;&#x2F; IE9 places a space on the end of the text in some cases so ignore last char
						return (range.endOffset == value.length-1);
					} else {
						return (range.endOffset == value.length);
					}
				} else if (startContainer.nodeType == 1) {
					return range.endOffset == startContainer.childNodes.length;
				}
				return false;
			}

			&#x2F;*
			 	If we are at the end of a list item surrounded with an element, pressing enter should create a
			 	new list item instead without splitting the element e.g. don&#x27;t want to create new P or H1 tag
			  *&#x2F;
			function isEndOfListItem() {
				var node = ed.selection.getNode();
				var validElements = &#x27;h1,h2,h3,h4,h5,h6,p,div&#x27;;
				var isLastParagraphOfLi = ed.dom.is(node, validElements) &amp;&amp; node.parentNode.tagName === &#x27;LI&#x27; &amp;&amp; node.parentNode.lastChild === node;
				return ed.selection.isCollapsed() &amp;&amp; isLastParagraphOfLi &amp;&amp; isCursorAtEndOfContainer();
			}

			&#x2F;&#x2F; Creates a new list item after the current selection&#x27;s list item parent
			function createNewLi(ed, e) {
				if (isEnterWithoutShift(e) &amp;&amp; isEndOfListItem()) {
					var node = ed.selection.getNode();
					var li = ed.dom.create(&quot;li&quot;);
					var parentLi = ed.dom.getParent(node, &#x27;li&#x27;);
					ed.dom.insertAfter(li, parentLi);

					&#x2F;&#x2F; Move caret to new list element.
					if (tinymce.isIE6 || tinymce.isIE7 || tinyMCE.isIE8) {
						&#x2F;&#x2F; Removed this line since it would create an odd &lt;&amp;nbsp;&gt; tag and placing the caret inside an empty LI is handled and should be handled by the selection logic
						&#x2F;&#x2F;li.appendChild(ed.dom.create(&quot;&amp;nbsp;&quot;)); &#x2F;&#x2F; IE needs an element within the bullet point
						ed.selection.setCursorLocation(li, 1);
					} else {
						ed.selection.setCursorLocation(li, 0);
					}
					e.preventDefault();
				}
			}

			function imageJoiningListItem(ed, e) {
				var prevSibling;

				if (!tinymce.isGecko)
					return;

				var n = ed.selection.getStart();
				if (e.keyCode != tinymce.VK.BACKSPACE || n.tagName !== &#x27;IMG&#x27;)
					return;

				function lastLI(node) {
					var child = node.firstChild;
					var li = null;
					do {
						if (!child)
							break;

						if (child.tagName === &#x27;LI&#x27;)
							li = child;
					} while (child = child.nextSibling);

					return li;
				}

				function addChildren(parentNode, destination) {
					while (parentNode.childNodes.length &gt; 0)
						destination.appendChild(parentNode.childNodes[0]);
				}

				&#x2F;&#x2F; Check if there is a previous sibling
				prevSibling = n.parentNode.previousSibling;
				if (!prevSibling)
					return;

				var ul;
				if (prevSibling.tagName === &#x27;UL&#x27; || prevSibling.tagName === &#x27;OL&#x27;)
					ul = prevSibling;
				else if (prevSibling.previousSibling &amp;&amp; (prevSibling.previousSibling.tagName === &#x27;UL&#x27; || prevSibling.previousSibling.tagName === &#x27;OL&#x27;))
					ul = prevSibling.previousSibling;
				else
					return;

				var li = lastLI(ul);

				&#x2F;&#x2F; move the caret to the end of the list item
				var rng = ed.dom.createRng();
				rng.setStart(li, 1);
				rng.setEnd(li, 1);
				ed.selection.setRng(rng);
				ed.selection.collapse(true);

				&#x2F;&#x2F; save a bookmark at the end of the list item
				var bookmark = ed.selection.getBookmark();

				&#x2F;&#x2F; copy the image an its text to the list item
				var clone = n.parentNode.cloneNode(true);
				if (clone.tagName === &#x27;P&#x27; || clone.tagName === &#x27;DIV&#x27;)
					addChildren(clone, li);
				else
					li.appendChild(clone);

				&#x2F;&#x2F; remove the old copy of the image
				n.parentNode.parentNode.removeChild(n.parentNode);

				&#x2F;&#x2F; move the caret where we saved the bookmark
				ed.selection.moveToBookmark(bookmark);
			}

			&#x2F;&#x2F; fix the cursor position to ensure it is correct in IE
			function setCursorPositionToOriginalLi(li) {
				var list = ed.dom.getParent(li, &#x27;ol,ul&#x27;);
				if (list != null) {
					var lastLi = list.lastChild;
					&#x2F;&#x2F; Removed this line since IE9 would report an DOM character error and placing the caret inside an empty LI is handled and should be handled by the selection logic
					&#x2F;&#x2F;lastLi.appendChild(ed.getDoc().createElement(&#x27;&#x27;));
					ed.selection.setCursorLocation(lastLi, 0);
				}
			}

			this.ed = ed;
			ed.addCommand(&#x27;Indent&#x27;, this.indent, this);
			ed.addCommand(&#x27;Outdent&#x27;, this.outdent, this);
			ed.addCommand(&#x27;InsertUnorderedList&#x27;, function() {
				this.applyList(&#x27;UL&#x27;, &#x27;OL&#x27;);
			}, this);
			ed.addCommand(&#x27;InsertOrderedList&#x27;, function() {
				this.applyList(&#x27;OL&#x27;, &#x27;UL&#x27;);
			}, this);

			ed.onInit.add(function() {
				ed.editorCommands.addCommands({
					&#x27;outdent&#x27;: function() {
						var sel = ed.selection, dom = ed.dom;

						function hasStyleIndent(n) {
							n = dom.getParent(n, dom.isBlock);
							return n &amp;&amp; (parseInt(ed.dom.getStyle(n, &#x27;margin-left&#x27;) || 0, 10) + parseInt(ed.dom.getStyle(n, &#x27;padding-left&#x27;) || 0, 10)) &gt; 0;
						}

						return hasStyleIndent(sel.getStart()) || hasStyleIndent(sel.getEnd()) || ed.queryCommandState(&#x27;InsertOrderedList&#x27;) || ed.queryCommandState(&#x27;InsertUnorderedList&#x27;);
					}
				}, &#x27;state&#x27;);
			});

			ed.onKeyUp.add(function(ed, e) {
				if (state == LIST_TABBING) {
					ed.execCommand(e.shiftKey ? &#x27;Outdent&#x27; : &#x27;Indent&#x27;, true, null);
					state = LIST_UNKNOWN;
					return Event.cancel(e);
				} else if (state == LIST_EMPTY_ITEM) {
					var li = getLi();
					var shouldOutdent =  ed.settings.list_outdent_on_enter === true || e.shiftKey;
					ed.execCommand(shouldOutdent ? &#x27;Outdent&#x27; : &#x27;Indent&#x27;, true, null);
					if (tinymce.isIE) {
						setCursorPositionToOriginalLi(li);
					}

					return Event.cancel(e);
				} else if (state == LIST_ESCAPE) {
					if (tinymce.isIE6 || tinymce.isIE7 || tinymce.isIE8) {
						&#x2F;&#x2F; append a zero sized nbsp so that caret is positioned correctly in IE after escaping and applying formatting.
						&#x2F;&#x2F; if there is no text then applying formatting for e.g a H1 to the P tag immediately following list after
						&#x2F;&#x2F; escaping from it will cause the caret to be positioned on the last li instead of staying the in P tag.
						var n = ed.getDoc().createTextNode(&#x27;\uFEFF&#x27;);
						ed.selection.getNode().appendChild(n);
					} else if (tinymce.isIE9 || tinymce.isGecko) {
						&#x2F;&#x2F; IE9 does not escape the list so we use outdent to do this and cancel the default behaviour
						&#x2F;&#x2F; Gecko does not create a paragraph outdenting inside a TD so default behaviour is cancelled and we outdent ourselves
						ed.execCommand(&#x27;Outdent&#x27;);
						return Event.cancel(e);
					}
				}
			});

			function fixListItem(parent, reference) {
				&#x2F;&#x2F; a zero-sized non-breaking space is placed in the empty list item so that the nested list is
				&#x2F;&#x2F; displayed on the below line instead of next to it
				var n = ed.getDoc().createTextNode(&#x27;\uFEFF&#x27;);
				parent.insertBefore(n, reference);
				ed.selection.setCursorLocation(n, 0);
				&#x2F;&#x2F; repaint to remove rendering artifact. only visible when creating new list
				ed.execCommand(&#x27;mceRepaint&#x27;);
			}

			function fixIndentedListItemForGecko(ed, e) {
				if (isEnter(e)) {
					var li = getLi();
					if (li) {
						var parent = li.parentNode;
						var grandParent = parent &amp;&amp; parent.parentNode;
						if (grandParent &amp;&amp; grandParent.nodeName == &#x27;LI&#x27; &amp;&amp; grandParent.firstChild == parent &amp;&amp; li == parent.firstChild) {
							fixListItem(grandParent, parent);
						}
					}
				}
			}

			function fixIndentedListItemForIE8(ed, e) {
				if (isEnter(e)) {
					var li = getLi();
					if (ed.dom.select(&#x27;ul li&#x27;, li).length === 1) {
						var list = li.firstChild;
						fixListItem(li, list);
					}
				}
			}

			function fixDeletingFirstCharOfList(ed, e) {
				function listElements(li) {
					var elements = [];
					var walker = new tinymce.dom.TreeWalker(li.firstChild, li);
					for (var node = walker.current(); node; node = walker.next()) {
						if (ed.dom.is(node, &#x27;ol,ul,li&#x27;)) {
							elements.push(node);
						}
					}
					return elements;
				}

				if (e.keyCode == tinymce.VK.BACKSPACE) {
					var li = getLi();
					if (li) {
						var list = ed.dom.getParent(li, &#x27;ol,ul&#x27;),
							rng  = ed.selection.getRng();
						if (list &amp;&amp; list.firstChild === li &amp;&amp; rng.startOffset == 0) {
							var elements = listElements(li);
							elements.unshift(li);
							ed.execCommand(&quot;Outdent&quot;, false, elements);
							ed.undoManager.add();
							return Event.cancel(e);
						}
					}
				}
			}

			function fixDeletingEmptyLiInWebkit(ed, e) {
				var li = getLi();
				if (e.keyCode === tinymce.VK.BACKSPACE &amp;&amp; ed.dom.is(li, &#x27;li&#x27;) &amp;&amp; li.parentNode.firstChild!==li) {
					if (ed.dom.select(&#x27;ul,ol&#x27;, li).length === 1) {
						var prevLi = li.previousSibling;
						ed.dom.remove(ed.dom.select(&#x27;br&#x27;, li));
						ed.dom.remove(li, true);
						var textNodes = tinymce.grep(prevLi.childNodes, function(n){ return n.nodeType === 3 });
						if (textNodes.length === 1) {
							var textNode = textNodes[0];
							ed.selection.setCursorLocation(textNode, textNode.length);
						}
						ed.undoManager.add();
						return Event.cancel(e);
					}
				}
			}

			ed.onKeyDown.add(function(_, e) { state = getListKeyState(e); });
			ed.onKeyDown.add(cancelDefaultEvents);
			ed.onKeyDown.add(imageJoiningListItem);
			ed.onKeyDown.add(createNewLi);

			if (tinymce.isGecko) {
				ed.onKeyUp.add(fixIndentedListItemForGecko);
			}
			if (tinymce.isIE8) {
				ed.onKeyUp.add(fixIndentedListItemForIE8);
			}
			if (tinymce.isGecko || tinymce.isWebKit) {
				ed.onKeyDown.add(fixDeletingFirstCharOfList);
			}
			if (tinymce.isWebKit) {
				ed.onKeyDown.add(fixDeletingEmptyLiInWebkit);
			}
		},

		applyList: function(targetListType, oppositeListType) {
			var t = this, ed = t.ed, dom = ed.dom, applied = [], hasSameType = false, hasOppositeType = false, hasNonList = false, actions,
					selectedBlocks = ed.selection.getSelectedBlocks();

			function cleanupBr(e) {
				if (e &amp;&amp; e.tagName === &#x27;BR&#x27;) {
					dom.remove(e);
				}
			}

			function makeList(element) {
				var list = dom.create(targetListType), li;

				function adjustIndentForNewList(element) {
					&#x2F;&#x2F; If there&#x27;s a margin-left, outdent one level to account for the extra list margin.
					if (element.style.marginLeft || element.style.paddingLeft) {
						t.adjustPaddingFunction(false)(element);
					}
				}

				if (element.tagName === &#x27;LI&#x27;) {
					&#x2F;&#x2F; No change required.
				} else if (element.tagName === &#x27;P&#x27; || element.tagName === &#x27;DIV&#x27; || element.tagName === &#x27;BODY&#x27;) {
					processBrs(element, function(startSection, br) {
						doWrapList(startSection, br, element.tagName === &#x27;BODY&#x27; ? null : startSection.parentNode);
						li = startSection.parentNode;
						adjustIndentForNewList(li);
						cleanupBr(br);
					});
					if (li) {
						if (li.tagName === &#x27;LI&#x27; &amp;&amp; (element.tagName === &#x27;P&#x27; || selectedBlocks.length &gt; 1)) {
							dom.split(li.parentNode.parentNode, li.parentNode);
						}
						attemptMergeWithAdjacent(li.parentNode, true);
					}
					return;
				} else {
					&#x2F;&#x2F; Put the list around the element.
					li = dom.create(&#x27;li&#x27;);
					dom.insertAfter(li, element);
					li.appendChild(element);
					adjustIndentForNewList(element);
					element = li;
				}
				dom.insertAfter(list, element);
				list.appendChild(element);
				attemptMergeWithAdjacent(list, true);
				applied.push(element);
			}

			function doWrapList(start, end, template) {
				var li, n = start, tmp;
				while (!dom.isBlock(start.parentNode) &amp;&amp; start.parentNode !== dom.getRoot()) {
					start = dom.split(start.parentNode, start.previousSibling);
					start = start.nextSibling;
					n = start;
				}
				if (template) {
					li = template.cloneNode(true);
					start.parentNode.insertBefore(li, start);
					while (li.firstChild) dom.remove(li.firstChild);
					li = dom.rename(li, &#x27;li&#x27;);
				} else {
					li = dom.create(&#x27;li&#x27;);
					start.parentNode.insertBefore(li, start);
				}
				while (n &amp;&amp; n != end) {
					tmp = n.nextSibling;
					li.appendChild(n);
					n = tmp;
				}
				if (li.childNodes.length === 0) {
					li.innerHTML = &#x27;&lt;br _mce_bogus=&quot;1&quot; &#x2F;&gt;&#x27;;
				}
				makeList(li);
			}

			function processBrs(element, callback) {
				var startSection, previousBR, END_TO_START = 3, START_TO_END = 1,
						breakElements = &#x27;br,ul,ol,p,div,h1,h2,h3,h4,h5,h6,table,blockquote,address,pre,form,center,dl&#x27;;

				function isAnyPartSelected(start, end) {
					var r = dom.createRng(), sel;
					bookmark.keep = true;
					ed.selection.moveToBookmark(bookmark);
					bookmark.keep = false;
					sel = ed.selection.getRng(true);
					if (!end) {
						end = start.parentNode.lastChild;
					}
					r.setStartBefore(start);
					r.setEndAfter(end);
					return !(r.compareBoundaryPoints(END_TO_START, sel) &gt; 0 || r.compareBoundaryPoints(START_TO_END, sel) &lt;= 0);
				}

				function nextLeaf(br) {
					if (br.nextSibling)
						return br.nextSibling;
					if (!dom.isBlock(br.parentNode) &amp;&amp; br.parentNode !== dom.getRoot())
						return nextLeaf(br.parentNode);
				}

				&#x2F;&#x2F; Split on BRs within the range and process those.
				startSection = element.firstChild;
				&#x2F;&#x2F; First mark the BRs that have any part of the previous section selected.
				var trailingContentSelected = false;
				each(dom.select(breakElements, element), function(br) {
					if (br.hasAttribute &amp;&amp; br.hasAttribute(&#x27;_mce_bogus&#x27;)) {
						return true; &#x2F;&#x2F; Skip the bogus Brs that are put in to appease Firefox and Safari.
					}
					if (isAnyPartSelected(startSection, br)) {
						dom.addClass(br, &#x27;_mce_tagged_br&#x27;);
						startSection = nextLeaf(br);
					}
				});
				trailingContentSelected = (startSection &amp;&amp; isAnyPartSelected(startSection, undefined));
				startSection = element.firstChild;
				each(dom.select(breakElements, element), function(br) {
					&#x2F;&#x2F; Got a section from start to br.
					var tmp = nextLeaf(br);
					if (br.hasAttribute &amp;&amp; br.hasAttribute(&#x27;_mce_bogus&#x27;)) {
						return true; &#x2F;&#x2F; Skip the bogus Brs that are put in to appease Firefox and Safari.
					}
					if (dom.hasClass(br, &#x27;_mce_tagged_br&#x27;)) {
						callback(startSection, br, previousBR);
						previousBR = null;
					} else {
						previousBR = br;
					}
					startSection = tmp;
				});
				if (trailingContentSelected) {
					callback(startSection, undefined, previousBR);
				}
			}

			function wrapList(element) {
				processBrs(element, function(startSection, br, previousBR) {
					&#x2F;&#x2F; Need to indent this part
					doWrapList(startSection, br);
					cleanupBr(br);
					cleanupBr(previousBR);
				});
			}

			function changeList(element) {
				if (tinymce.inArray(applied, element) !== -1) {
					return;
				}
				if (element.parentNode.tagName === oppositeListType) {
					dom.split(element.parentNode, element);
					makeList(element);
					attemptMergeWithNext(element.parentNode, false);
				}
				applied.push(element);
			}

			function convertListItemToParagraph(element) {
				var child, nextChild, mergedElement, splitLast;
				if (tinymce.inArray(applied, element) !== -1) {
					return;
				}
				element = splitNestedLists(element, dom);
				while (dom.is(element.parentNode, &#x27;ol,ul,li&#x27;)) {
					dom.split(element.parentNode, element);
				}
				&#x2F;&#x2F; Push the original element we have from the selection, not the renamed one.
				applied.push(element);
				element = dom.rename(element, &#x27;p&#x27;);
				mergedElement = attemptMergeWithAdjacent(element, false, ed.settings.force_br_newlines);
				if (mergedElement === element) {
					&#x2F;&#x2F; Now split out any block elements that can&#x27;t be contained within a P.
					&#x2F;&#x2F; Manually iterate to ensure we handle modifications correctly (doesn&#x27;t work with tinymce.each)
					child = element.firstChild;
					while (child) {
						if (dom.isBlock(child)) {
							child = dom.split(child.parentNode, child);
							splitLast = true;
							nextChild = child.nextSibling &amp;&amp; child.nextSibling.firstChild;
						} else {
							nextChild = child.nextSibling;
							if (splitLast &amp;&amp; child.tagName === &#x27;BR&#x27;) {
								dom.remove(child);
							}
							splitLast = false;
						}
						child = nextChild;
					}
				}
			}

			each(selectedBlocks, function(e) {
				e = findItemToOperateOn(e, dom);
				if (e.tagName === oppositeListType || (e.tagName === &#x27;LI&#x27; &amp;&amp; e.parentNode.tagName === oppositeListType)) {
					hasOppositeType = true;
				} else if (e.tagName === targetListType || (e.tagName === &#x27;LI&#x27; &amp;&amp; e.parentNode.tagName === targetListType)) {
					hasSameType = true;
				} else {
					hasNonList = true;
				}
			});

			if (hasNonList &amp;&amp;!hasSameType || hasOppositeType || selectedBlocks.length === 0) {
				actions = {
					&#x27;LI&#x27;: changeList,
					&#x27;H1&#x27;: makeList,
					&#x27;H2&#x27;: makeList,
					&#x27;H3&#x27;: makeList,
					&#x27;H4&#x27;: makeList,
					&#x27;H5&#x27;: makeList,
					&#x27;H6&#x27;: makeList,
					&#x27;P&#x27;: makeList,
					&#x27;BODY&#x27;: makeList,
					&#x27;DIV&#x27;: selectedBlocks.length &gt; 1 ? makeList : wrapList,
					defaultAction: wrapList,
					elements: this.selectedBlocks()
				};
			} else {
				actions = {
					defaultAction: convertListItemToParagraph,
					elements: this.selectedBlocks(),
					processEvenIfEmpty: true
				};
			}
			this.process(actions);
		},

		indent: function() {
			var ed = this.ed, dom = ed.dom, indented = [];

			function createWrapItem(element) {
				var wrapItem = dom.create(&#x27;li&#x27;, { style: &#x27;list-style-type: none;&#x27;});
				dom.insertAfter(wrapItem, element);
				return wrapItem;
			}

			function createWrapList(element) {
				var wrapItem = createWrapItem(element),
						list = dom.getParent(element, &#x27;ol,ul&#x27;),
						listType = list.tagName,
						listStyle = dom.getStyle(list, &#x27;list-style-type&#x27;),
						attrs = {},
						wrapList;
				if (listStyle !== &#x27;&#x27;) {
					attrs.style = &#x27;list-style-type: &#x27; + listStyle + &#x27;;&#x27;;
				}
				wrapList = dom.create(listType, attrs);
				wrapItem.appendChild(wrapList);
				return wrapList;
			}

			function indentLI(element) {
				if (!hasParentInList(ed, element, indented)) {
					element = splitNestedLists(element, dom);
					var wrapList = createWrapList(element);
					wrapList.appendChild(element);
					attemptMergeWithAdjacent(wrapList.parentNode, false);
					attemptMergeWithAdjacent(wrapList, false);
					indented.push(element);
				}
			}

			this.process({
				&#x27;LI&#x27;: indentLI,
				defaultAction: this.adjustPaddingFunction(true),
				elements: this.selectedBlocks()
			});

		},

		outdent: function(ui, elements) {
			var t = this, ed = t.ed, dom = ed.dom, outdented = [];

			function outdentLI(element) {
				var listElement, targetParent, align;
				if (!hasParentInList(ed, element, outdented)) {
					if (dom.getStyle(element, &#x27;margin-left&#x27;) !== &#x27;&#x27; || dom.getStyle(element, &#x27;padding-left&#x27;) !== &#x27;&#x27;) {
						return t.adjustPaddingFunction(false)(element);
					}
					align = dom.getStyle(element, &#x27;text-align&#x27;, true);
					if (align === &#x27;center&#x27; || align === &#x27;right&#x27;) {
						dom.setStyle(element, &#x27;text-align&#x27;, &#x27;left&#x27;);
						return;
					}
					element = splitNestedLists(element, dom);
					listElement = element.parentNode;
					targetParent = element.parentNode.parentNode;
					if (targetParent.tagName === &#x27;P&#x27;) {
						dom.split(targetParent, element.parentNode);
					} else {
						dom.split(listElement, element);
						if (targetParent.tagName === &#x27;LI&#x27;) {
							&#x2F;&#x2F; Nested list, need to split the LI and go back out to the OL&#x2F;UL element.
							dom.split(targetParent, element);
						} else if (!dom.is(targetParent, &#x27;ol,ul&#x27;)) {
							dom.rename(element, &#x27;p&#x27;);
						}
					}
					outdented.push(element);
				}
			}

			var listElements = elements &amp;&amp; tinymce.is(elements, &#x27;array&#x27;) ? elements : this.selectedBlocks();
			this.process({
				&#x27;LI&#x27;: outdentLI,
				defaultAction: this.adjustPaddingFunction(false),
				elements: listElements
			});

			each(outdented, attemptMergeWithAdjacent);
		},

		process: function(actions) {
			var t = this, sel = t.ed.selection, dom = t.ed.dom, selectedBlocks, r;

			function isEmptyElement(element) {
				var excludeBrsAndBookmarks = tinymce.grep(element.childNodes, function(n) {
					return !(n.nodeName === &#x27;BR&#x27; || n.nodeName === &#x27;SPAN&#x27; &amp;&amp; dom.getAttrib(n, &#x27;data-mce-type&#x27;) == &#x27;bookmark&#x27;
							|| n.nodeType == 3 &amp;&amp; (n.nodeValue == String.fromCharCode(160) || n.nodeValue == &#x27;&#x27;));
				});
				return excludeBrsAndBookmarks.length === 0;
			}

			function processElement(element) {
				dom.removeClass(element, &#x27;_mce_act_on&#x27;);
				if (!element || element.nodeType !== 1 || ! actions.processEvenIfEmpty &amp;&amp; selectedBlocks.length &gt; 1 &amp;&amp; isEmptyElement(element)) {
					return;
				}
				element = findItemToOperateOn(element, dom);
				var action = actions[element.tagName];
				if (!action) {
					action = actions.defaultAction;
				}
				action(element);
			}

			function recurse(element) {
				t.splitSafeEach(element.childNodes, processElement, true);
			}

			function brAtEdgeOfSelection(container, offset) {
				return offset &gt;= 0 &amp;&amp; container.hasChildNodes() &amp;&amp; offset &lt; container.childNodes.length &amp;&amp;
						container.childNodes[offset].tagName === &#x27;BR&#x27;;
			}

			function isInTable() {
				var n = sel.getNode();
				var p = dom.getParent(n, &#x27;td&#x27;);
				return p !== null;
			}

			selectedBlocks = actions.elements;

			r = sel.getRng(true);
			if (!r.collapsed) {
				if (brAtEdgeOfSelection(r.endContainer, r.endOffset - 1)) {
					r.setEnd(r.endContainer, r.endOffset - 1);
					sel.setRng(r);
				}
				if (brAtEdgeOfSelection(r.startContainer, r.startOffset)) {
					r.setStart(r.startContainer, r.startOffset + 1);
					sel.setRng(r);
				}
			}


			if (tinymce.isIE8) {
				&#x2F;&#x2F; append a zero sized nbsp so that caret is restored correctly using bookmark
				var s = t.ed.selection.getNode();
				if (s.tagName === &#x27;LI&#x27; &amp;&amp; !(s.parentNode.lastChild === s)) {
					var i = t.ed.getDoc().createTextNode(&#x27;\uFEFF&#x27;);
					s.appendChild(i);
				}
			}

			bookmark = sel.getBookmark();
			actions.OL = actions.UL = recurse;
			t.splitSafeEach(selectedBlocks, processElement);
			sel.moveToBookmark(bookmark);
			bookmark = null;

			&#x2F;&#x2F; we avoid doing repaint in a table as this will move the caret out of the table in Firefox 3.6
			if (!isInTable()) {
				&#x2F;&#x2F; Avoids table or image handles being left behind in Firefox.
				t.ed.execCommand(&#x27;mceRepaint&#x27;);
			}
		},

		splitSafeEach: function(elements, f, forceClassBase) {
			if (forceClassBase ||
				(tinymce.isGecko &amp;&amp;
					(&#x2F;Firefox\&#x2F;[12]\.[0-9]&#x2F;.test(navigator.userAgent) ||
					 &#x2F;Firefox\&#x2F;3\.[0-4]&#x2F;.test(navigator.userAgent)))) {
				this.classBasedEach(elements, f);
			} else {
				each(elements, f);
			}
		},

		classBasedEach: function(elements, f) {
			var dom = this.ed.dom, nodes, element;
			&#x2F;&#x2F; Mark nodes
			each(elements, function(element) {
				dom.addClass(element, &#x27;_mce_act_on&#x27;);
			});
			nodes = dom.select(&#x27;._mce_act_on&#x27;);
			while (nodes.length &gt; 0) {
				element = nodes.shift();
				dom.removeClass(element, &#x27;_mce_act_on&#x27;);
				f(element);
				nodes = dom.select(&#x27;._mce_act_on&#x27;);
			}
		},

		adjustPaddingFunction: function(isIndent) {
			var indentAmount, indentUnits, ed = this.ed;
			indentAmount = ed.settings.indentation;
			indentUnits = &#x2F;[a-z%]+&#x2F;i.exec(indentAmount);
			indentAmount = parseInt(indentAmount, 10);
			return function(element) {
				var currentIndent, newIndentAmount;
				currentIndent = parseInt(ed.dom.getStyle(element, &#x27;margin-left&#x27;) || 0, 10) + parseInt(ed.dom.getStyle(element, &#x27;padding-left&#x27;) || 0, 10);
				if (isIndent) {
					newIndentAmount = currentIndent + indentAmount;
				} else {
					newIndentAmount = currentIndent - indentAmount;
				}
				ed.dom.setStyle(element, &#x27;padding-left&#x27;, &#x27;&#x27;);
				ed.dom.setStyle(element, &#x27;margin-left&#x27;, newIndentAmount &gt; 0 ? newIndentAmount + indentUnits : &#x27;&#x27;);
			};
		},

		selectedBlocks: function() {
			var ed = this.ed, selectedBlocks = ed.selection.getSelectedBlocks();
			return selectedBlocks.length == 0 ? [ ed.dom.getRoot() ] : selectedBlocks;
		},

		getInfo: function() {
			return {
				longname : &#x27;Lists&#x27;,
				author : &#x27;Moxiecode Systems AB&#x27;,
				authorurl : &#x27;http:&#x2F;&#x2F;tinymce.moxiecode.com&#x27;,
				infourl : &#x27;http:&#x2F;&#x2F;wiki.moxiecode.com&#x2F;index.php&#x2F;TinyMCE:Plugins&#x2F;lists&#x27;,
				version : tinymce.majorVersion + &quot;.&quot; + tinymce.minorVersion
			};
		}
	});
	tinymce.PluginManager.add(&quot;lists&quot;, tinymce.plugins.Lists);
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
